'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var queryStateCore = require('query-state-core');

var LOCATION_STATE_KEY = '__useLocationState';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var hasWindowLocation = typeof window !== "undefined" && 'location' in window && 'history' in window;
function useHashQueryStringInterface(_a) {
    var _b = (_a === void 0 ? {} : _a).disabled, disabled = _b === void 0 ? false : _b;
    var enabled = !disabled && hasWindowLocation;
    var hashQSI = react.useMemo(function () { return ({
        getQueryString: function () {
            if (!enabled)
                return '';
            return window.location.hash;
        },
        setQueryString: function (newQueryString, _a) {
            var _b = _a.method, method = _b === void 0 ? 'replace' : _b;
            if (!enabled)
                return;
            // use history to update hash using replace / push
            window.history[method === 'replace' ? 'replaceState' : 'pushState'](window.history.state, '', '#' + newQueryString);
            // manually dispatch a hashchange event (replace state does not trigger this event)
            // so all subscribers get notified (old way for IE11)
            var customEvent = document.createEvent('CustomEvent');
            customEvent.initEvent('hashchange', false, false);
            window.dispatchEvent(customEvent);
            setR(function (r) { return r + 1; });
        },
    }); }, [enabled]);
    // this state is used to trigger re-renders
    var _c = react.useState(0), setR = _c[1];
    react.useEffect(function () {
        if (!enabled)
            return;
        var hashChangeHandler = function () {
            setR(function (r) { return r + 1; });
        };
        window.addEventListener('hashchange', hashChangeHandler, false);
        return function () { return window.removeEventListener('hashchange', hashChangeHandler, false); };
    }, [enabled]);
    return hashQSI;
}

function useQueryStateObj(defaultQueryState, queryStateOpts) {
    var queryStringInterface = queryStateOpts.queryStringInterface;
    var hashQSI = useHashQueryStringInterface(queryStringInterface && { disabled: true });
    var activeQSI = queryStringInterface || hashQSI;
    var queryString = activeQSI.getQueryString();
    var _a = react.useState(), setLatestMergedQueryString = _a[1];
    var queryState = react.useMemo(function () { return (__assign(__assign({}, defaultQueryState), queryStateCore.parseQueryState(queryString))); }, [defaultQueryState, queryString]);
    var ref = react.useRef({
        defaultQueryState: defaultQueryState,
        queryStateOpts: queryStateOpts,
        activeQSI: activeQSI,
    });
    var setQueryState = react.useCallback(function (newState, opts) {
        var _a = ref.current, defaultQueryState = _a.defaultQueryState, queryStateOpts = _a.queryStateOpts, activeQSI = _a.activeQSI;
        var _b = queryStateOpts.stripDefaults, stripDefaults = _b === void 0 ? true : _b;
        var stripOverwrite = {};
        // when a params are set to the same value as in the defaults
        // we remove them to avoid having two URLs reproducing the same state unless stripDefaults === false
        if (stripDefaults) {
            Object.entries(newState).forEach(function (_a) {
                var key = _a[0];
                if (defaultQueryState[key] === newState[key]) {
                    stripOverwrite[key] = null;
                }
            });
        }
        // retrieve the last value (by re-executing the search getter)
        var currentQueryState = __assign(__assign({}, defaultQueryState), queryStateCore.parseQueryState(activeQSI.getQueryString()));
        var mergedQueryString = queryStateCore.createMergedQuery(currentQueryState || {}, newState, stripOverwrite);
        activeQSI.setQueryString(mergedQueryString, opts || {});
        // triggers an update (in case the QueryStringInterface misses to do so)
        setLatestMergedQueryString(mergedQueryString);
    }, []);
    react.useEffect(function () {
        ref.current = {
            defaultQueryState: defaultQueryState,
            queryStateOpts: queryStateOpts,
            activeQSI: activeQSI,
        };
    });
    return [queryState, setQueryState];
}

function sameAsJsonString(compareValueA, compareValueB) {
    return JSON.stringify(compareValueA) === JSON.stringify(compareValueB);
}
function useQueryState(itemName, defaultValue, queryStateOpts) {
    if (queryStateOpts === void 0) { queryStateOpts = {}; }
    defaultValue = react.useState(defaultValue)[0];
    var defaultQueryStateValue = queryStateCore.toQueryStateValue(defaultValue);
    var defaultQueryState = react.useMemo(function () {
        var _a;
        return defaultQueryStateValue
            ? (_a = {},
                _a[itemName] = defaultQueryStateValue,
                _a) : {};
    }, [itemName, defaultQueryStateValue]);
    if (defaultQueryStateValue === null) {
        throw new Error('unsupported defaultValue');
    }
    var _a = useQueryStateObj(defaultQueryState, queryStateOpts), queryState = _a[0], setQueryState = _a[1];
    var setQueryStateItem = react.useCallback(function (newValue, opts) {
        var _a;
        // stringify the given value (or array of strings)
        var newQueryStateValue = queryStateCore.toQueryStateValue(newValue);
        // warn when value type is not supported (do not warn when null was passed explicitly)
        if ((newQueryStateValue === null && newValue !== newQueryStateValue) ||
            !(newQueryStateValue !== null &&
                typeof queryStateCore.parseQueryStateValue(newQueryStateValue, defaultValue) === typeof defaultValue)) {
            console.warn('value of ' +
                JSON.stringify(newValue) +
                ' is not supported. "' +
                itemName +
                '" will reset to default value', defaultValue);
            newQueryStateValue = null;
        }
        // when new value is equal to default, we call setQueryState with a null value to reset query string
        // arrays have to be compared json stringified, other values can compared by value
        if (Array.isArray(defaultValue) && sameAsJsonString(newValue, defaultValue)) {
            newQueryStateValue = null;
        }
        else if (newValue === defaultValue) {
            newQueryStateValue = null;
        }
        setQueryState((_a = {}, _a[itemName] = newQueryStateValue, _a), opts);
    }, [defaultValue, itemName, setQueryState]);
    // fallback to default value
    var value = defaultValue;
    var queryStateItem = queryState[itemName];
    var queryStateValue = null;
    if (queryStateItem || queryStateItem === '') {
        queryStateValue = queryStateCore.parseQueryStateValue(queryStateItem, defaultValue);
    }
    if (queryStateValue !== null && typeof queryStateValue === typeof defaultValue) {
        value = queryStateValue;
    }
    return [value, setQueryStateItem];
}

function useHashQueryState(itemName, defaultValue, queryStateOpts) {
    if (queryStateOpts === void 0) { queryStateOpts = {}; }
    var hashQSI = useHashQueryStringInterface();
    return useQueryState(itemName, defaultValue, __assign(__assign({}, queryStateOpts), { queryStringInterface: hashQSI }));
}

var hasWindowHistory = typeof window !== "undefined" && 'history' in window;
function useLocationStateInterface(_a) {
    var _b = (_a === void 0 ? {} : _a).disabled, disabled = _b === void 0 ? false : _b;
    var enabled = !disabled && hasWindowHistory;
    // this state is used to trigger re-renders
    var _c = react.useState(0), setR = _c[1];
    var locationStateInterface = react.useMemo(function () { return ({
        getLocationState: function () {
            if (!enabled)
                return {};
            var historyState = window.history.state;
            return ((historyState &&
                LOCATION_STATE_KEY in historyState &&
                historyState[LOCATION_STATE_KEY]) ||
                {});
        },
        setLocationState: function (nextState, _a) {
            var _b;
            var _c = _a.method, method = _c === void 0 ? 'replace' : _c;
            if (!enabled)
                return null;
            var historyState = window.history.state || {};
            var updatedState = __assign(__assign({}, historyState), (_b = {}, _b[LOCATION_STATE_KEY] = nextState, _b));
            // update history state using replace / push
            window.history[method === 'replace' ? 'replaceState' : 'pushState'](updatedState, '', '');
            // manually dispatch a hashchange event (replace state does not trigger this event)
            // so all subscribers get notified (old way for IE11)
            var customEvent = document.createEvent('CustomEvent');
            customEvent.initEvent('popstate', false, false);
            window.dispatchEvent(customEvent);
        },
    }); }, [enabled]);
    react.useEffect(function () {
        if (!enabled)
            return;
        var hashChangeHandler = function () {
            setR(function (r) { return r + 1; });
        };
        window.addEventListener('popstate', hashChangeHandler, false);
        return function () { return window.removeEventListener('popstate', hashChangeHandler, false); };
    }, [enabled]);
    return locationStateInterface;
}

var validTypes = ['string', 'number', 'boolean', 'object', 'undefined'];
var locationStateOptsDefaults = Object.freeze({});
function useLocationState(itemName, defaultValue, _a) {
    var locationStateInterface = (_a === void 0 ? locationStateOptsDefaults : _a).locationStateInterface;
    defaultValue = react.useState(defaultValue)[0];
    // throw for invalid values like functions
    if (!validTypes.includes(typeof defaultValue)) {
        throw new Error('unsupported defaultValue');
    }
    itemName = react.useState(function () {
        var suffixObscurer = typeof btoa !== "undefined" ? btoa : (function (s) { return s; });
        var suffix = suffixObscurer(Array.isArray(defaultValue) ? 'array' : typeof defaultValue).replace(/=/g, '');
        return itemName + "__" + suffix;
    })[0];
    // the interface to get/set the state
    var standardLSI = useLocationStateInterface(locationStateInterface && { disabled: true });
    var activeLSI = locationStateInterface || standardLSI;
    var ref = react.useRef({
        activeLSI: activeLSI,
    });
    var currentState = activeLSI.getLocationState();
    var value = react.useMemo(function () {
        var value = defaultValue;
        if (itemName in currentState) {
            value = currentState[itemName];
        }
        return value;
    }, [currentState, defaultValue, itemName]);
    var resetLocationStateItem = react.useCallback(function (opts) {
        var activeLSI = ref.current.activeLSI;
        var newState = __assign({}, activeLSI.getLocationState());
        delete newState[itemName];
        activeLSI.setLocationState(newState, opts);
    }, [itemName]);
    var setLocationStateItem = react.useCallback(function (newValueOrFn, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var _b = ref.current.activeLSI, getLocationState = _b.getLocationState, setLocationState = _b.setLocationState;
        var newValue;
        var currentState = getLocationState();
        var currentValue = itemName in currentState ? currentState[itemName] : defaultValue;
        if (typeof newValueOrFn === 'function') {
            // @ts-ignore
            newValue = newValueOrFn(currentValue);
        }
        else {
            newValue = newValueOrFn;
        }
        if (newValue === defaultValue) {
            return resetLocationStateItem(opts);
        }
        // warn about invalid new values
        if (!validTypes.includes(typeof newValue)) {
            console.warn(newValue, 'value is not supported, reset to default');
            return resetLocationStateItem(opts);
        }
        var stateExtendOverwrite = (_a = {},
            _a[itemName] = newValue,
            _a);
        setLocationState(__assign(__assign({}, getLocationState()), stateExtendOverwrite), opts);
    }, [defaultValue, itemName, resetLocationStateItem]);
    react.useEffect(function () {
        ref.current = {
            activeLSI: activeLSI,
        };
    });
    return [value, setLocationStateItem];
}

exports.LOCATION_STATE_KEY = LOCATION_STATE_KEY;
exports.useHashQueryState = useHashQueryState;
exports.useLocationState = useLocationState;
exports.useQueryState = useQueryState;
